//-------------------------------------------------------------------------------
// Copyright IBM Corp. 2016
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-------------------------------------------------------------------------------

'use strict';

const _ = require('lodash'),	
      argv = require('argv'),
      async = require('async'),
      cfenv = require('cfenv'),
      debug = require('debug')('slack_graph_util');
   
const IBMGraphClient = require('ibm-graph-client');

const SGM = require('./lib/slack_graph_model.js'),
      gmio = require('./lib/graph_model_io.js');

/*
 * Generate a Slack graph model from a Slack team statistics file.
 * 
 * Invocation: node build-slack-graph-model.js -f /path/to/slack_team_stats_file.json
 * 
 * To bind an IBM Graph instance when running this application locally, copy the Bluemix service "credentials" property into file vcap.services.
 * [ ----------------- Example content ----------------- ]
 * 
 *    {
 *     "IBM Graph": [
 *      {
 *          "name": "slack-graph-database",
 *          "label": "IBM Graph",
 *          "plan": "Entry",
 *          "credentials": {
 *            "apiURL": "https://ibmgraph-alpha.ng.bluemix.net/9c6e7377-82a4-4dad-a1e2-4223e776349A/g",
 *            "username": "d3c76e27-5d3b-4b68-9dBc-278326cD3bc7",
 *            "password": "121212-c354-444-55-66666"
 *         }
 *        }
 *     ]
 *   }
 *
 * [ ----------------- End example content ----------------- ]
 */

/*
 * Process command line parameters
 */
	argv.info( 'Use this script to generate a Slack graph model from a Slack team statistics file.' );

	const args = argv.option([
								{ name: 'stats', short: 's', description: 'Slack team statistics file name. This file is generated by running slack-setup/generate-slack-stats.js', type: 'string' },
								{ name: 'name', short: 'n', description: 'Slack model name. Identifies the graph model.', type: 'string' },
								{ name: 'user_lookup', short: 'u', description: 'Location of exported users.json (optional, but recommended)', type: 'string' },
								{ name: 'channel_lookup', short: 'c', description: 'Location of exported channels.json (optional, but recommended)', type: 'string' },
							  ]).run();

	const statisticsFileName = args.options.stats;
	const modelName = args.options.name;

	var optionMissing = false;

	if(! statisticsFileName) {
		optionMissing = true;
		console.error('You must specify a Slack team statistics file: -s </path/to/slack_team_stats_file.json>');
	}

	if(! modelName) {
		optionMissing = true;
		console.error('You must specify a model name: -n <Slack model name>');
	}

	if(optionMissing) {
		argv.help();
		process.exit(1);    
	}

	var statsFile = null;
	try {
		 statsFile = require(statisticsFileName); // array of slack statistics objects identified by the channel name
	}
	catch(exception) {
		console.error('The Slack team statistics file could not be loaded: ' + exception);
		process.exit(1);    
	}

	//
	// If user_lookup option was specified, try to load users.json; this file contains Slack user metadata information.
	//
	var userLookup = {};
	try {
		 if(args.options.user_lookup) {
		 	_.forEach(require(args.options.user_lookup), function (userMetadata) {
		 		if(userMetadata.name) {
		 			userLookup[userMetadata.id]= {name: userMetadata.name};			
		 		}
		 		
		 	}); // 
		 	console.error('Slack export file users.json was loaded. User names will be added to the model.'); 
		 }
		 else {
		 	console.error('Slack export file users.json location was not specified. Only internal user IDs will be added to the model.'); 
		 }
	}
	catch(exception) {
		console.error('Slack export file users.json was not loaded. Only internal user IDs will be added to the model.');   
	}

	//
	// If channel_lookup option was specified, try to load channels.json; this file contains Slack channel metadata information.
	//
	var channelLookup = {};
	try {
		 if(args.options.channel_lookup) {
		 	_.forEach(require(args.options.channel_lookup), function (channelMetadata) {
		 		channelLookup[channelMetadata.id] = {name: channelMetadata.name};
		 		// additional properties can be added but require changes in slack_graph_model.js and (potentially) the IBM Graph schema		
		 	}); 
		 	console.error('Slack export file channels.json was loaded. Channel names will be added to the model.'); 
		 }
		 else {
			console.error('Slack export file channels.json location was not specified. Only internal channel IDs will be added to the model.'); 	
		 }
		 
	}
	catch(exception) {
		console.error('Slack export file channel.json was not loaded. Only internal channel IDs will be added to the model: ' + exception);   
	}

/*
 * Establish connectivity to the Graph database
 */

	var appEnv = null;

	try {
	  appEnv = cfenv.getAppEnv({vcap: {services: require('./vcap_services.json')}});
	}
	catch(ex) {
	  appEnv = cfenv.getAppEnv();
	}

	var graphServiceCredentials = appEnv.getServiceCreds('slack-graph-database');

	if(! graphServiceCredentials) {
	    throw new Error('This application is not bound to a Bluemix hosted IBM Graph. Set the VCAP_SERVICES environment variable or add the service information to file vcap_services.json.');
	}

	var GraphClient = new IBMGraphClient({url: graphServiceCredentials.apiURL, username: graphServiceCredentials.username, password: graphServiceCredentials.password});

	// obtain session token from Graph DB
	GraphClient.session(function (error, token){

		GraphClient.config.session = token;

	});

/*
 * Build graph model
 */	

	var sgm = new SGM.SlackGraphModel(modelName);
	sgm.setUserInfoLookup(userLookup);
	sgm.setChannelInfoLookup(channelLookup);

	var whiteList = []; 

	// iterate through user stats for each channel
	async.eachSeries(statsFile, function(channelStats, callback) {

		if((_.find(whiteList, 
			      function(channelName) {
			      	return (Object.keys(channelStats)[0] === channelName);
		          })) || (whiteList.length === 0)) {

			debug('Processing channel ' + Object.keys(channelStats)[0]);

			// add channel vertex to graph
			sgm.addChannel(Object.keys(channelStats)[0]);
			
			_.forEach(channelStats[Object.keys(channelStats)[0]].user_msg_stats.data, 
					  function(userData) {

						// add user vertex to graph
						sgm.addUser(Object.keys(userData)[0]);	 								// user id

						// add is_in_channel edge to graph
						sgm.addIsInChannel(Object.keys(userData)[0], 							// user id
										   Object.keys(channelStats)[0],					    // channel id
										   userData[Object.keys(userData)[0]].message_count		// user id's message count in channel id
										  );

					  	_.forEach(userData[Object.keys(userData)[0]].mention, function(mentions) {
							// add mentions_user edges to graph                                 
							sgm.addMentionsUsers(Object.keys(userData)[0],						// user id
								 			 	 Object.keys(mentions)[0], 						// mentioned user id
											     mentions[Object.keys(mentions)[0]],			// number of times user id mentioned <mentioned user id>
											     Object.keys(channelStats)[0]					// channel id in which user id mentioned <mentioned user id>
											    );	  					  		
					  	});
					  }
			);

			// add mentions_channel edges to graph
			_.forEach(channelStats[Object.keys(channelStats)[0]].user_msg_stats.data, 
					  function(userData) {
					  	_.forEach(userData[Object.keys(userData)[0]].channel_mention, function(mentions) {
							sgm.addMentionsChannel(Object.keys(userData)[0],					    // user Id
								                   Object.keys(mentions)[0],			        	// mentioned channel id
											       mentions[Object.keys(mentions)[0]],			    // number of times userId mentioned channel Id
											       Object.keys(channelStats)[0]					    // channel id in which user id mentioned <mentioned channel id>
											      );	  					  		
					  	});
					  }
			);	

			// process next element in async.eachSeries
			callback();

		}
			else {
				debug('Skipping channel ' + Object.keys(channelStats)[0]);
				callback();	
			}
		},
		function(err) {

			if(err) {
				console.error('Error: ' + err);	
			}
			else {

					console.log('Graph statistics:');
					console.log(' User vertices: ' + sgm.idCounters.user);
					console.log(' Channel vertices: ' + sgm.idCounters.channel);
					console.log(' User is_in_channel edges: ' + sgm.idCounters.iiChannel);
					console.log(' User mentions_user edges: ' + sgm.idCounters.mUser);
					console.log(' User mentions_channel edges: ' + sgm.idCounters.mChannel);

					var sgmio = new gmio.GraphModelIO(sgm);

					// save in-memory graph model to disk
					sgmio.saveModelInFile('.', function(error, fileName){
						if(error) {
							console.error('Eror saving in-memory graph model:' + error);
						}
						else {
							console.log('Graph model for Slack team "' + sgm.getModelName() + '" was saved in file ' + fileName + '.');	
						}
						
					});
			}
		}
	); // async.eachSeries
