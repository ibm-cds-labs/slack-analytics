//-------------------------------------------------------------------------------
// Copyright IBM Corp. 2016
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-------------------------------------------------------------------------------

'use strict';

const _ = require('lodash'),	
      argv = require('argv'),
      async = require('async'),
      debug = require('debug')('slack_graph_util');

const SGM = require('./lib/slack_graph_model.js'),
      gmio = require('./lib/graph_model_io.js');

/* 
	-------------------------------------------------------------------------------------------------------------------------------------
	Build a Slack graph model using social and keyword stats collected from Slack message archive files.
	Run ../stats/collect-slack-stats.js to collect social statistics 
	Run ../stats/collect-keyword-stats.js to collect keyword statistics 
	-------------------------------------------------------------------------------------------------------------------------------------
	Parameters:
					-s /path/to/<team_name>-social_stats_file.json		(required)
					-k /path/to/<team_name>-keyword-stats.json			(required)
					-n team_name 										(required)
					-c /path/to/extracted/slack/channels.json 			(not required but recommended)
					-u /path/to/extracted/slack/users.json 				(not required but recommended)
	Services: 
					n/a	
	Debug switches:
					slack_graph_util
	-------------------------------------------------------------------------------------------------------------------------------------
*/

	/*
 	 * Process command line parameters
 	 */
	argv.info( 'Use this script to generate a Slack graph model from a Slack team statistics file.' );

	const args = argv.option([
								{ name: 'social', short: 's', description: 'Slack team social statistics file name. This file is generated by running slack-stats/collect-slack-stats.js', type: 'string' },
								{ name: 'keyword', short: 'k', description: 'Slack team keyword statistics file name. This file is generated by running slack-stats/collect-keyword-stats.js', type: 'string' },
								{ name: 'name', short: 'n', description: 'Slack model name. Identifies the graph model.', type: 'string' },
								{ name: 'user_lookup', short: 'u', description: 'Location of exported users.json (optional, but recommended)', type: 'string' },
								{ name: 'channel_lookup', short: 'c', description: 'Location of exported channels.json (optional, but recommended)', type: 'string' },
							  ]).run();

	const socialStatsFileName = args.options.social;
	const knowledgeStatsFileName = args.options.keyword;
	const modelName = args.options.name;

	var optionMissing = false;

	if(! socialStatsFileName) {
		optionMissing = true;
		console.error('You must specify a Slack team social statistics file: -s </path/to/team_name-social_stats_file.json>');
	}

	if(! modelName) {
		optionMissing = true;
		console.error('You must specify a model name: -n <Slack model name>');
	}

	if(optionMissing) {
		argv.help();
		process.exit(1);    
	}

	var socialStatsFile = null;
	try {
		 socialStatsFile = require(socialStatsFileName); // array of slack statistics objects identified by the channel name
		 debug('Loaded social statistics file ' + socialStatsFileName);
	}
	catch(exception) {
		console.error('The Slack team social statistics file ' +  socialStatsFileName + ' could not be loaded: ' + exception);
		process.exit(1);    
	}

	var knowledgeStatsFile = null;
	if(knowledgeStatsFileName) {

		/*
			This file is generated by ../generate-keyword-stats.js

			{ 
				"slack_team_name": "<my-slack-team-name>",		// Slack team name
				"collection_date": "2016-07-26T18:29:33.288Z",  // ISO 8601 formatted timestamp indicating when the extraction process was run
				"keyword_statistics": [
									   "<channel_id>": {
												    	"channel_keywords": [
																		      {
																		        "relevance": "0.991585",
																		        "text": "cloudant"
																		      },
																		      ...
																		    ],
														"user_data": {
																      "<INTERNAL_SLACK_USER_ID>": {
																        "message_count": 29,
																        "message_batches": [
																          					"..."
																        ],
																        "keywords": [
																          				{
																            				"relevance": "0.957723",
																            				"text": "dashDB"
																          				},
																          				...							    
									  												]
									  								  }			 
																	 }
													   }
									  ]
			}
	
		 */

		try {
			 knowledgeStatsFile = require(knowledgeStatsFileName); // array of keyword statistics objects identified by the channel name
			 console.log('Knowledge statistics file ' + knowledgeStatsFileName + ' was loaded. Keywords will be added to the model.');
		}
		catch(exception) {
			console.error('The Slack team keyword statistics file ' + socialStatsFileName + ' could not be loaded: ' + exception);
			process.exit(1);    
		}		
	}
	else {
		console.log('No knowledge statistics file name was provided. Keywords will not be added to the model.');
	}

	//
	// If user_lookup option was specified, try to load users.json; this file contains Slack user metadata information.
	//
	var userLookup = {};
	try {
		 if(args.options.user_lookup) {
		 	_.forEach(require(args.options.user_lookup), function (userMetadata) {
		 		if(userMetadata.name) {
		 			userLookup[userMetadata.id]= {name: userMetadata.name};			
		 		}
		 		
		 	}); // 
		 	console.error('Slack export file users.json was loaded. User names will be added to the model.'); 
		 }
		 else {
		 	console.error('Slack export file users.json location was not specified. Only internal user IDs will be added to the model.'); 
		 }
	}
	catch(exception) {
		console.error('Slack export file users.json was not loaded. Only internal user IDs will be added to the model: ' + exception);   
	}

	//
	// If channel_lookup option was specified, try to load channels.json; this file contains Slack channel metadata information.
	//
	var channelLookup = {};
	try {
		 if(args.options.channel_lookup) {
		 	_.forEach(require(args.options.channel_lookup), function (channelMetadata) {
		 		channelLookup[channelMetadata.id] = {name: channelMetadata.name};
		 		// additional properties can be added but require changes in slack_graph_model.js and (potentially) the IBM Graph schema		
		 	}); 
		 	console.error('Slack export file channels.json was loaded. Channel names will be added to the model.'); 
		 }
		 else {
			console.error('Slack export file channels.json location was not specified. Only internal channel IDs will be added to the model.'); 	
		 }
		 
	}
	catch(exception) {
		console.error('Slack export file channel.json was not loaded. Only internal channel IDs will be added to the model: ' + exception);   
	}

	/*
	 * Build graph model
	 */	

	var sgm = new SGM.SlackGraphModel(modelName);
	sgm.setUserInfoLookup(userLookup);
	sgm.setChannelInfoLookup(channelLookup);

	var channelId = null,
		channelStatsProperty = null,
		channelStatsValue = null,
		whiteList = []; 

	// iterate through user stats for each channel
	async.eachSeries(socialStatsFile, function(channelStats, callback) {

		if((_.find(whiteList, 
			      function(channelName) {
			      	return (Object.keys(channelStats)[0] === channelName);
		          })) || (whiteList.length === 0)) {


			channelId = Object.keys(channelStats)[0];

			debug('Processing channel ' + channelId);

			// add channel vertex to graph
			sgm.addChannel(channelId);

			/*
			   add social graph vertices and edges:
			   	- User (vertex)
			   	- [User] is_in_channel (edge)
			   	- [User] mentions_user (edge)
			   	- [User] mentions_channel (edge)
			*/   
			
			_.forEach(channelStats[channelId].user_msg_stats.data, 
					  function(userData) {

						// add user vertex to graph
						sgm.addUser(Object.keys(userData)[0]);	 								// user id

						// add is_in_channel edge to graph
						sgm.addIsInChannel(Object.keys(userData)[0], 							// user id
										   channelId,					    					// channel id
										   userData[Object.keys(userData)[0]].message_count		// user id's message count in channel id
										  );

					  	_.forEach(userData[Object.keys(userData)[0]].mention, function(mentions) {
							// add mentions_user edges to graph                                 
							sgm.addMentionsUsers(Object.keys(userData)[0],						// user id
								 			 	 Object.keys(mentions)[0], 						// mentioned user id
											     mentions[Object.keys(mentions)[0]],			// number of times user id mentioned <mentioned user id>
											     channelId										// channel id in which user id mentioned <mentioned user id>
											    );	  					  		
					  	});
					  }
			);

			// add mentions_channel edges to graph
			_.forEach(channelStats[channelId].user_msg_stats.data, 
					  function(userData) {
					  	_.forEach(userData[Object.keys(userData)[0]].channel_mention, function(mentions) {
							sgm.addMentionsChannel(Object.keys(userData)[0],					    // user Id
								                   Object.keys(mentions)[0],			        	// mentioned channel id
											       mentions[Object.keys(mentions)[0]],			    // number of times userId mentioned channel Id
											       channelId					    				// channel id in which user id mentioned <mentioned channel id>
											      );	  					  		
					  	});
					  }
			);	


			/*
			   add knowledge graph vertices and edges if a knowledge statisctics file was provided:
			    - keyword (vertex)
			   	- [User] mentions_keyword (edge)
			   	- [Keyword] used_in_channel (edge)
			*/  

			if(knowledgeStatsFile) {

				channelStatsProperty = _.find(knowledgeStatsFile.keyword_statistics, 
											  function (o) {
											   				return (Object.keys(o)[0] === channelId);
											  });
 
			    if(channelStatsProperty) {

			    	// keyword statistics are available for this channel; add them to the model

					debug('Found keyword statistics for channel ' + channelId);

					channelStatsValue = channelStatsProperty[Object.keys(channelStatsProperty)[0]];

					/*	input data structure
					 		{
								"channel_keywords": [
 									// see details below (1)
        						],
        						"user_data": {
									// see details below (2)
    							}
					 		}				 
					*/

	             	// model associations between keywords and channels
	             	// (a) create keyword vertex (channel vertex was already added to the model)
	             	// (b) associate keyword vertex with channel vertex
	             	_.forEach(channelStatsValue.channel_keywords,
		     	 		      function(keywordObj) {
			                	/*	details from above: (1)
									{
										"relevance": "0.999377",
										"text": "cloudant sync work"
									},
									...
			                	*/

	   							// add keyword vertex to graph (if it doesn't already exist)
	     	 					sgm.addKeyword(keywordObj.text); 	
	     	 					// add [keyword] used_in_channel edge to graph (if it doesn't already exist)
	     	 					sgm.addUsedInChannel(keywordObj.text, channelId);
		     	 			   });	             	 	

	             	// model associations between keywords and users
	             	// (a) create keyword vertex (user vertex must already exist)
	             	// (b) associate keyword with user
					_.forEach(Object.keys(channelStatsValue.user_data), 
					          function(userId) { 
					            /* details from above: (2)
					             		
			             		  {
			             	       "<internal Slack userId>": {
    															"message_count": <number of messages that were analyzed>,
											        			"keywords": [
																	          {
																	            "relevance": "0.959361",
																	            "text": "Cloudant"
																	          },
																	          ...
														        ]
														      },
								   "<internal Slack userId>": {
																 ...
									                          }				
								  }

					            */

					            if(channelStatsValue.user_data[userId].hasOwnProperty('keywords')) {

				             	 	// add keyword vertices and [user] mentions_keyword edges
				             	 	_.forEach(channelStatsValue.user_data[userId].keywords,
				             	 		      function(keywordObj) {
				           						// add keyword vertex to graph (if it doesn't exist already)
				             	 				sgm.addKeyword(keywordObj.text); 	
				             	 				// add [user] mentions_keyword edge to graph (if it doesn't exist already)
				             	 				sgm.addMentionsKeyword(userId, keywordObj.text);
				             	 			  });	             	 	
					            }
					          }); 

					} // if(channelStatsValue) {
			} // if(knowledgeStatsFile) {

			// process next element in async.eachSeries
			return callback();

		 }
		 else {
				debug('Skipping channel ' + Object.keys(channelStats)[0]);
				return callback();	
		 }
		}, // async.eachSeries(socialStatsFile, ...
		function(err) {

			if(err) {
				console.error('Error: ' + err);	
			}
			else {

					console.log('Graph statistics:');
					console.log(' User vertices: ' + sgm.idCounters.user);
					console.log(' Channel vertices: ' + sgm.idCounters.channel);
					console.log(' Keyword vertices: ' + sgm.idCounters.keyword);
					console.log(' User is_in_channel edges: ' + sgm.idCounters.iiChannel);
					console.log(' User mentions_user edges: ' + sgm.idCounters.mUser);
					console.log(' User mentions_channel edges: ' + sgm.idCounters.mChannel);
					console.log(' User mentions_keyword edges: ' + sgm.idCounters.mKeyword);
					console.log(' Keyword used_in_channel edges: ' + sgm.idCounters.uiChannel);

					var sgmio = new gmio.GraphModelIO(sgm);

					// save in-memory graph model in the current directory
					sgmio.saveModelInFile('.', function(error, fileName){
						if(error) {
							console.error('Eror saving in-memory graph model to file ' + fileName + ' :' + error);
						}
						else {
							console.log('Graph model for Slack team "' + sgm.getModelName() + '" was saved in file ' + fileName + '.');	
							console.log('Load this model into an IBM Graph instance by running "node load-slack-graph-model.js -m ' + fileName + '"');	
						}
						
					});
			}
		}
	); // async.eachSeries
