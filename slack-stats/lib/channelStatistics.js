'use strict';

var _ = require('lodash');

var BasicMsg = require('./messages/basicMsg.js');


/**
 * Encapsulates Slack channel statistics 
 * @param {string} _channelName - slack channel name
 */
var ChannelStatistics = function (_channelName) {

	var channelName = _channelName;

	var channelStats = {
							total_messages: 0,
							first_message_timestamp: null,	// unix style (e.g. 1430746612) + ".<some_numbers>"
							last_message_timestamp: null	// unix style (e.g. 1430746612) + ".<some_numbers>"
					   },
		botMsgStats = {											// messages that were issued by Slack integrations
						total: 0,
						data: {}
					  },
	    userMsgStats = {										// messages that were issued by humans
						total: 0,
						data: {}	    	
	    			   },
	    systemMsgStats = {										// messages that were issued by Slack 
	    					total: 0,
	    					data: {
									channel_join: 0,
									channel_leave: 0,
									channel_purpose: 0,
									channel_topic: 0,
									file_share: 0,
									me_message: 0,
									pinned_item: 0,	    						
									unpinned_item: 0
	    					}
	    				},
		unclassifiedMsgStats = {
	    							total: 0,		// if total > 0 the parser wasn't able to classify the message; parser update is needed
									data: {}	    								
							   },
		calendarDateMessageCount = {};				// #messages per day
							   

	/**
	 * Updates channel statistics based 
	 * @param {Object} slackMessageObj - an instance of messages/basicMsg 
	 * 
	 */
	this.update = function(slackMessageObj) {

		// only accept slack message objects inheriting from the BasicMsg class
		if((!slackMessageObj)||(! slackMessageObj instanceof BasicMsg)) {
			return;
		}

		// increase message count
		channelStats.total_messages++;

		// track first and last message timestamp information
		if((!channelStats.first_message_timestamp) || (slackMessageObj.getTimestamp().localeCompare(channelStats.first_message_timestamp) === -1)) {			
			channelStats.first_message_timestamp = slackMessageObj.getTimestamp();
		}

		if((!channelStats.last_message_timestamp) || (slackMessageObj.getTimestamp().localeCompare(channelStats.last_message_timestamp) === 1)) {	
			channelStats.last_message_timestamp = slackMessageObj.getTimestamp();
		}

		// update message class specific information

		if(slackMessageObj.isSysMsg()) {
			// system generated message
			systemMsgStats.total++;

			if(systemMsgStats.data.hasOwnProperty(slackMessageObj.getMsgType())) {
				systemMsgStats.data[slackMessageObj.getMsgType()]++;
			}
			else {
				// this indicates that the parser implementation is out of sync with this class (all known message types should be pre-initialized)
				systemMsgStats.data[slackMessageObj.getMsgType()] = 1;
			}

		}
		else {

			if(slackMessageObj.isUserMsg()) {
				// user generated message
				userMsgStats.total++;

				// keep track of how many messages were generated by this user
				if(userMsgStats.data.hasOwnProperty(slackMessageObj.getUser())) {
					userMsgStats.data[slackMessageObj.getUser()]++;
				}
				else {
					userMsgStats.data[slackMessageObj.getUser()] = 1;
				}
			}
			else {

				if(slackMessageObj.isBotMsg()) {
					// bot generated message
					botMsgStats.total++;

					// keep track of how many messages were generated by this bot
					if(botMsgStats.data.hasOwnProperty(slackMessageObj.getBotId())) {
						botMsgStats.data[slackMessageObj.getBotId()]++;
					}
					else {
						botMsgStats.data[slackMessageObj.getBotId()] = 1;
					}
				}
				else {
					// unclassified message
					unclassifiedMsgStats.total++;
					// keep track of how many messages couldn't be classified
					// A parser update is required to properly classifiy these messages
					if(unclassifiedMsgStats.data.hasOwnProperty(slackMessageObj.getMsgType())) {
						unclassifiedMsgStats.data[slackMessageObj.getMsgType()]++;
					}
					else {
						unclassifiedMsgStats.data[slackMessageObj.getMsgType()] = 1;
					}

				}
			}
		} 

		// count # messages per day
		var calendarDate = getDateString(slackMessageObj.getTimestamp());
		if(calendarDateMessageCount.hasOwnProperty(calendarDate)) {
				calendarDateMessageCount[calendarDate]++;
		}
		else {
				calendarDateMessageCount[calendarDate] = 1;
		}

	};						   

	/**
	 * @returns {string} identifies the channel for which the statistics were collected
	 */						   
	this.getChannelName = function() {
		return channelName;
	};

	/**
	 * @returns {Object} statistics - statistics about the slack channel. Note that if unclassified_message_count > 0
	 * it's time to update the slack message parser.
 	 * @returns {number} statistics.channel_message_count - number of messages in channel
 	 * @returns {number} statistics.user_message_count - number of user generated messages in channel
 	 * @returns {number} statistics.bot_message_count - number of bot generated messages in channel
 	 * @returns {number} statistics.system_message_count - number of system generated messages in channel
 	 * @returns {number} statistics.unclassified_message_count - number of messages that could not be classified
	 */	
	this.getChannelStats = function() {
		return { 
					channel_message_count: channelStats.total_messages, 
					user_message_count: userMsgStats.total_messages, 
					bot_message_count: botMsgStats.total_messages, 
					system_message_count: systemMsgStats.total_messages,
					unclassified_message_count: unclassifiedMsgStats.total_messages 
			   };
	};

	/**
	 * @returns {Object} statistics about messages that were issued by Slack
	 * @returns {number} statistics.total - number of system generated messages in channel
	 * @returns {number} statistics.channel_join - number of join [channel] messages
	 * @returns {number} statistics.channel_leave - number of leave [channel] messages
	 * @returns {number} statistics.channel_purpose - number of change [channel] purpose messages
	 * @returns {number} statistics.channel_topic - number of change [channel] topic messages
	 * @returns {number} statistics.file_share - number of file share messages
	 * @returns {number} statistics.me_message - number of change status messages
	 * @returns {number} statistics.pinned_item - number of pin item messages
	 */	
	this.getSystemMsgStats = function() {
		return systemMsgStats;
	};

	/**
	 * @returns {Object} statistics about messages that were issued by a human
	 * @returns {number} statistics.total - number of user generated messages in channel	 
	 */	
	this.getUserMsgStats = function() {
		return userMsgStats;
	};

	/**
	 * @returns {Object} statistics about messages that were issued by bots
	 * @returns {number} statistics.total - number of bot generated messages in channel	 
	 */	
	this.getBotMsgStats = function() {
		return botMsgStats;
	};

	/**
	 * @returns {Object} statistics about Slack messages that could not be classified. The presence of unclassified messages
	 * indicates that there is a potential message parser problem.
	 * @returns {number} statistics.total - number of messages that could not be classified
	 */	
	this.getUnclassifiedMsgStats = function() {
		return unclassifiedMsgStats;
	};

	/**
	 * @returns {string} JSON representation of the channel statistics
	 */	
	this.toJSON = function() {

		var toArray = function(obj) {

			var arr = [];
			_.forEach(_.keys(obj).sort(), function (property) {
				arr.push({ [property]: obj[property]});
			});

			return arr;

		};

		return '{ "' + channelName + '":' +  
				  	'{ "system_messages": ' + 
						'{ "total": ' + systemMsgStats.total + ',' +
						  '"data": ' +JSON.stringify(toArray(systemMsgStats.data))  + '},' + 
				  	' "user_messages": ' + 
						'{ "total": ' + userMsgStats.total + ',' +
						  '"data": ' +JSON.stringify(toArray(userMsgStats.data))  + '},' + 
				  	' "bot_messages": ' + 
						'{ "total": ' + botMsgStats.total + ',' +
						  '"data": ' +JSON.stringify(toArray(botMsgStats.data))  + '},' + 						
				  	' "unclassified_messages": ' + 
						'{ "total": ' + unclassifiedMsgStats.total + ',' +
						  '"data": ' +JSON.stringify(toArray(unclassifiedMsgStats.data))  + '},' + 
				  	' "messages_per_day": ' + 
						JSON.stringify(toArray(calendarDateMessageCount)) + 
		       '}}';
	};
						

	// -------------------------------------------------------------------------------------

	/**
	 * Utility function, extracting the calendar date from a slack timestamp
	 * @returns {string} calendar date formatted according to ISO 8601 (YYYY-MM-DD)
	 */
	var getDateString = function(slackTimestamp) {

		var date = new Date(slackTimestamp.substring(0,slackTimestamp.indexOf('.')) * 1000);

		return (date.toISOString().substring(0,10));
	};

};

module.exports = ChannelStatistics;